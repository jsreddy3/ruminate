from typing import List, Optional, Dict, Any, Tuple
import uuid
import logging
from datetime import datetime
from src.models.conversation.message import Message, MessageRole
from src.models.conversation.agent_process_step import AgentProcessStep, AgentProcessStepType
from src.repositories.interfaces.conversation_repository import ConversationRepository
from src.repositories.interfaces.agent_process_repository import AgentProcessRepository
from src.services.ai.llm_service import LLMService
from src.services.ai.context_service import ContextService
from src.services.conversation.agent.document_exploration_tools import DocumentExplorationTools
from src.services.conversation.agent.response_parser import AgentResponseParser
from src.services.conversation.agent.sse_manager import SSEManager
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)

class AgentLoopRunner:
    """
    Responsible for running the agent loop that explores documents and generates answers.
    This class manages the iterative process of agent reasoning, tool usage, and answer generation.
    """
    def __init__(self,
                llm_service: LLMService,
                tools: DocumentExplorationTools,
                response_parser: AgentResponseParser,
                conversation_repository: ConversationRepository,
                agent_process_repository: AgentProcessRepository,
                context_service: ContextService,
                sse_manager: Optional[SSEManager] = None,
                max_iterations: int = 4):
        self.llm_service = llm_service
        self.tools = tools
        self.response_parser = response_parser
        self.conversation_repo = conversation_repository
        self.agent_process_repo = agent_process_repository
        self.context_service = context_service
        self.sse_manager = sse_manager
        self.max_iterations = max_iterations
        logger.debug("AgentLoopRunner initialized")
    
    async def run_agent_loop(self,
                         agent_state: Dict,
                         active_thread: List[str],
                         session: Optional[AsyncSession]) -> str:
        """
        Run the agent loop that explores the document and generates an answer.
        
        Args:
            agent_state: Dictionary containing conversation state and tracking information
            active_thread: List of message IDs in the active conversation thread
            session: Database session for transactions
            
        Returns:
            str: The final answer generated by the agent
        """
        # Initialize state and tracking
        self._initialize_agent_state(agent_state, active_thread)
        
        # Build initial message context using context service
        messages = await self._build_context_from_service(agent_state, active_thread, session)
        
        # Run the main agent loop
        final_answer, assistant_msg_id = await self._execute_agent_iterations(
            agent_state, messages, active_thread, session
        )
        
        # Save the collected process steps to the database
        await self._save_process_steps(agent_state, assistant_msg_id, session)
        
        return final_answer
    
    def _initialize_agent_state(self, agent_state: Dict, active_thread: List[str]) -> None:
        """Initialize or validate the agent state dictionary with required fields."""
        # Initialize process steps collection if not present
        if "process_steps" not in agent_state:
            agent_state["process_steps"] = []
        
        # Store the user message ID for linking process steps
        if "user_message_id" not in agent_state and active_thread:
            agent_state["user_message_id"] = active_thread[-1]
        
        # Ensure we have an exploration history
        if "exploration_history" not in agent_state:
            agent_state["exploration_history"] = []
            
        # Log the initialization
        logger.info(f"Initialized agent state for conversation: {agent_state['conversation_id']}")

    async def _build_context_from_service(self, 
                                agent_state: Dict, 
                                active_thread: List[str],
                                session: AsyncSession) -> List[Message]:
        """Build the message context using the context service.
        
        This creates the proper conversation context for the LLM with:
        1. One system message at the beginning
        2. The conversation history in the correct order
        3. The current user question
        """
        conversation_id = agent_state["conversation_id"]
        
        # Get conversation to access needed metadata
        conversation = await self.conversation_repo.get_conversation(conversation_id, session)
        
        # Let the context service build the complete system message with all context
        system_content = await self.context_service.build_agent_system_prompt(
            conversation_id=conversation_id,
            document_id=conversation.document_id,
            session=session
        )
        
        # Create the system message
        system_msg = Message(
            id="system_message",
            conversation_id=conversation_id,
            role=MessageRole.SYSTEM,
            content=system_content
        )
        
        # Get active thread messages
        active_thread_messages = await self.conversation_repo.get_active_thread(
            conversation_id, session
        )
        
        # Start with the system message
        messages = [system_msg]
        
        # Add conversation history from the active thread
        if active_thread_messages:
            messages.extend(active_thread_messages)
        
        # Add the current user question if not already in the active thread
        latest_message = active_thread_messages[-1] if active_thread_messages else None
        
        if not latest_message or latest_message.role != MessageRole.USER or latest_message.content != agent_state["user_message"]:
            user_question_msg = Message(
                id="user_question",
                conversation_id=conversation_id,
                role=MessageRole.USER,
                content=f"QUESTION: {agent_state['user_message']}\n\nExplore the document to answer this question step by step."
            )
            messages.append(user_question_msg)
        
        return messages
    
    async def _execute_agent_iterations(self,
                                  agent_state: Dict,
                                  messages: List[Message],
                                  active_thread: List[str],
                                  session: AsyncSession) -> Tuple[str, str]:
        """
        Execute the main agent iteration loop.
        
        Returns:
            Tuple[str, str]: (final_answer, assistant_message_id)
        """
        iterations = 0
        final_answer = None
        assistant_message_id = None
        
        # Extract system message for later use
        system_msg = next((msg for msg in messages if msg.role == MessageRole.SYSTEM), None)
        
        # Create a working copy of messages that we'll update during iterations
        working_messages = messages.copy()
        
        while iterations < self.max_iterations and not final_answer:
            iterations += 1
            logger.info(f"Agent iteration {iterations}/{self.max_iterations}")
            
            try:
                # Generate the next agent action
                action_data = await self._generate_agent_action(working_messages, iterations, agent_state)
                
                # Handle error in action generation
                if "error" in action_data:
                    error_msg = f"Error in structured response: {action_data['error']}"
                    self._handle_error(
                        working_messages, agent_state, iterations, 
                        error_msg,
                        "Please try a different approach."
                    )
                    continue
                
                # Process the action based on type
                if action_data.get("response_type") == "answer":
                    # Process final answer
                    final_answer, assistant_message_id = await self._process_answer(
                        action_data, agent_state, active_thread, system_msg, iterations, session
                    )
                elif action_data.get("response_type") == "action":
                    # Process tool action
                    await self._process_action(
                        action_data, agent_state, working_messages, iterations, session
                    )
                else:
                    # Handle invalid response type
                    error_msg = f"Invalid response_type: {action_data.get('response_type')}"
                    self._handle_error(
                        working_messages, agent_state, iterations,
                        error_msg,
                        "Please provide either 'action' or 'answer'."
                    )
            except Exception as e:
                # Handle any exceptions during iteration
                error_msg = f"Error in agent loop: {str(e)}"
                self._handle_error(
                    working_messages, agent_state, iterations,
                    error_msg,
                    "Please try a different approach."
                )
                
                # Send error event to client if configured
                if self.sse_manager:
                    await self.sse_manager.send_event(
                        agent_state["conversation_id"],
                        "agent_error",
                        {"message": f"Error: {str(e)}"}
                    )
        
        # If we reached max iterations without an answer, use a different approach for the final iteration
        if not final_answer and iterations >= self.max_iterations:
            # Use specialized final iteration approach instead of timeout
            final_answer, assistant_message_id = await self._generate_final_answer(
                agent_state, active_thread, system_msg, iterations, session
            )
        # Handle timeout if we didn't get a final answer for other reasons
        elif not final_answer:
            final_answer, assistant_message_id = await self._handle_timeout(
                agent_state, active_thread, system_msg, iterations, session
            )
        
        return final_answer, assistant_message_id
    
    async def _generate_agent_action(self, 
                           messages: List[Message], 
                           iteration: int,
                           agent_state: Dict) -> Dict:
        """Generate the next action from the LLM."""
        logger.debug(f"Generating structured response for iteration {iteration}")
        
        try:
            # Get instructions and schema
            action_schema = self.context_service.get_agent_action_schema()
            
            # Check if this is the last iteration
            is_last_iteration = (iteration >= self.max_iterations)
            
            # Add a warning message if this is the last iteration
            if is_last_iteration:
                # Find the system message and add a note about last iteration
                for msg in messages:
                    if msg.role == MessageRole.SYSTEM:
                        # Add a note to the system message content about this being the last iteration
                        last_iteration_note = "\n\nIMPORTANT: This is your LAST opportunity to provide an answer. After this, you must return your best answer with what you've found so far."
                        msg.content += last_iteration_note
                        break
            
            action_data = await self.llm_service.generate_structured_response(
                messages=messages,
                response_format={"type": "json_object"},
                json_schema=action_schema
            )
            logger.info(f"Received structured action data: {action_data}")
            return action_data
        except Exception as e:
            logger.error(f"Error generating agent action: {e}")
            return {"error": str(e)}
    
    def _handle_error(self, 
                     messages: List[Message], 
                     agent_state: Dict, 
                     iteration: int, 
                     error_message: str,
                     suggestion: str = "") -> None:
        """Handle errors in the agent loop consistently."""
        # Create error message for LLM context only (as a User message to maintain the conversation flow)
        full_message = f"ERROR: {error_message}"
        if suggestion:
            full_message += f" {suggestion}"
            
        error_msg = Message(
            id=f"error_{iteration}",
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.USER,  # Use USER role to maintain proper conversation flow
            content=full_message
        )
        messages.append(error_msg)
        
        # Create error process step
        error_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration, "error"),
            step_type=AgentProcessStepType.ERROR,
            content=error_message,
            metadata={"iteration": iteration}
        )
        agent_state["process_steps"].append(error_step)
        logger.error(f"Agent error (iteration {iteration}): {error_message}")
    
    async def _process_answer(self,
                        action_data: Dict,
                        agent_state: Dict,
                        active_thread: List[str],
                        system_msg: Message,
                        iteration: int,
                        session: AsyncSession) -> Tuple[str, str]:
        """Process a final answer from the agent.
        
        Returns:
            Tuple[str, str]: (final_answer, message_id)
        """
        final_answer = action_data["answer"]
        logger.info("Agent has produced a final answer")
        
        # Record final thought in exploration history
        agent_state["exploration_history"].append({
            "step": iteration,
            "type": "final_answer",
            "content": action_data["thought"],
            "answer": final_answer
        })
        
        # Create process step for final thought
        thought_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration, "thought"),
            step_type=AgentProcessStepType.THOUGHT,
            content=action_data["thought"],
            metadata={"iteration": iteration, "is_final": True}
        )
        agent_state["process_steps"].append(thought_step)
        
        # Send event to client
        if self.sse_manager:
            await self.sse_manager.send_event(
                agent_state["conversation_id"],
                "agent_answer",
                {"message": "Agent has found an answer.", "answer": final_answer}
            )
        
        # Create and save the final answer message
        parent_id = agent_state["user_message_id"] if "user_message_id" in agent_state else (
            active_thread[-1] if active_thread else system_msg.id
        )
        
        final_answer_msg = Message(
            id=str(uuid.uuid4()),
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.ASSISTANT,
            content=final_answer,  # Clean content without prefixes
            parent_id=parent_id,
            metadata={"message_type": "agent_final_answer", "hidden": False}
        )
        await self.conversation_repo.add_message(final_answer_msg, session)
        
        # Update the active thread if needed
        if final_answer_msg.id not in active_thread:
            active_thread.append(final_answer_msg.id)
        
        return final_answer, final_answer_msg.id
    
    async def _process_action(self,
                        action_data: Dict,
                        agent_state: Dict,
                        messages: List[Message],
                        iteration: int,
                        session: AsyncSession) -> None:
        """Process an action request from the agent."""
        # Extract action details
        action = action_data["action"]
        action_input = action_data["action_input"]
        thought = action_data["thought"]
        
        logger.info(f"Executing action: {action} with input: {action_input}")
        
        # First, add the agent's thought as an ASSISTANT message to maintain the right flow
        thought_msg = Message(
            id=f"thought_{iteration}",
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.ASSISTANT,
            content=f"I need to {action} with {action_input}. {thought}"
        )
        messages.append(thought_msg)
        
        # Execute the tool action
        result = await self.tools.execute_action(
            action=action,
            action_input=action_input,
            agent_state=agent_state,
            session=session
        )
        result_summary = result[:100] + "..." if isinstance(result, str) and len(result) > 100 else result
        logger.debug(f"Action result: {result_summary}")
        
        # Record in exploration history
        agent_state["exploration_history"].append({
            "step": iteration,
            "type": "tool_use",
            "thought": thought,
            "action": action,
            "input": action_input,
            "result": result[:500] if isinstance(result, str) else str(result)[:500]
        })
        
        # Add the tool result as a USER message to maintain proper conversation flow
        # (tools are external information sources from the LLM's perspective)
        tool_msg = Message(
            id=f"tool_{iteration}",
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.USER,  # USER role for tools/external info
            content=f"TOOL: {action}\nINPUT: {action_input}\nRESULT: {result}"
        )
        messages.append(tool_msg)
        
        # Create process steps for the agent's work
        self._create_action_process_steps(
            agent_state, iteration, thought, action, action_input, result
        )
        
        # Send event to client
        if self.sse_manager:
            await self.sse_manager.send_event(
                agent_state["conversation_id"],
                "agent_action",
                {
                    "action": action,
                    "input": action_input,
                    "result_preview": result_summary
                }
            )
    
    def _create_action_process_steps(self,
                                   agent_state: Dict,
                                   iteration: int,
                                   thought: str,
                                   action: str,
                                   action_input: str,
                                   result: Any) -> None:
        """Create the process steps for an action sequence."""
        # Step 1: Thought
        thought_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration, "thought"),
            step_type=AgentProcessStepType.THOUGHT,
            content=thought,
            metadata={"iteration": iteration}
        )
        
        # Step 2: Action
        action_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration, "action"),
            step_type=AgentProcessStepType.ACTION,
            content=f"Action: {action}\nInput: {action_input}",
            metadata={
                "iteration": iteration,
                "action": action,
                "action_input": action_input
            }
        )
        
        # Step 3: Result
        result_content = result if isinstance(result, str) else str(result)
        result_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration, "result"),
            step_type=AgentProcessStepType.RESULT,
            content=result_content,
            metadata={"iteration": iteration}
        )
        
        # Add all steps to the collection
        agent_state["process_steps"].extend([thought_step, action_step, result_step])
    
    async def _generate_final_answer(self,
                           agent_state: Dict,
                           active_thread: List[str],
                           system_msg: Message,
                           iteration: int,
                           session: AsyncSession) -> Tuple[str, str]:
        """
        Generate a final answer using a simplified prompt focused solely on summarizing findings.
        This approach is used in the final iteration to get an answer without tool instructions.
        
        Returns:
            Tuple[str, str]: (final_answer, message_id)
        """
        logger.info("Using final iteration approach to generate an answer")
        
        # Create an exploration summary from the history
        exploration_summary = self._summarize_exploration(agent_state["exploration_history"])
        
        # Create template variables
        template_vars = {
            "user_message": agent_state["user_message"],
            "exploration_summary": exploration_summary
        }
        
        # Get the special final iteration message
        final_iteration_message = self.context_service.get_final_iteration_message(template_vars)
        
        # Create a new system message that's focused only on answering
        final_system_msg = Message(
            id="final_system_message",
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.SYSTEM,
            content=final_iteration_message
        )
        
        # Create a simplified message list with just the system message and user question
        user_msg = Message(
            id="user_question",
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.USER,
            content=agent_state["user_message"]
        )
        
        final_messages = [final_system_msg, user_msg]
        
        # Get the simplified schema for final answers
        final_schema = self.context_service.get_final_iteration_schema()
        
        try:
            # Generate a structured response with the simplified prompt and schema
            response = await self.llm_service.generate_structured_response(
                messages=final_messages,
                response_format={"type": "json_object"},
                json_schema=final_schema
            )
            
            # Extract the answer
            if "answer" in response:
                final_answer = response["answer"]
                logger.info("Generated final answer using simplified prompt")
                
                # Create and save the answer message
                parent_id = agent_state["user_message_id"]
                answer_msg = Message(
                    id=str(uuid.uuid4()),
                    conversation_id=agent_state["conversation_id"],
                    role=MessageRole.ASSISTANT,
                    content=final_answer,
                    parent_id=parent_id,
                    metadata={"message_type": "final_answer", "simplified_prompt": True}
                )
                
                await self.conversation_repo.add_message(answer_msg, session)
                
                # Update active thread
                if answer_msg.id not in active_thread:
                    active_thread.append(answer_msg.id)
                    await self.conversation_repo.update_active_thread(
                        agent_state["conversation_id"], active_thread, session
                    )
                
                # Create a process step for this final answer
                final_step = AgentProcessStep(
                    id=str(uuid.uuid4()),
                    conversation_id=agent_state["conversation_id"],
                    user_message_id=agent_state["user_message_id"],
                    assistant_message_id=answer_msg.id,
                    step_number=self._calculate_step_number(iteration + 1, "answer"),
                    step_type=AgentProcessStepType.RESULT,
                    content="Final answer generated using simplified prompt approach.",
                    meta_data={"iteration": iteration + 1, "simplified_prompt": True}
                )
                
                agent_state["process_steps"].append(final_step)
                
                # Send an event if SSE manager is configured
                if self.sse_manager:
                    await self.sse_manager.send_event(
                        agent_state["conversation_id"],
                        "agent_answer",
                        {"message": "Final answer generated."}
                    )
                
                return final_answer, answer_msg.id
            
            # If there's no answer field, fall back to the timeout approach
            logger.warning("Final iteration response missing 'answer' field, falling back to timeout")
            return await self._handle_timeout(agent_state, active_thread, system_msg, iteration, session)
            
        except Exception as e:
            logger.error(f"Error generating final answer with simplified prompt: {e}")
            # Fall back to the timeout approach
            return await self._handle_timeout(agent_state, active_thread, system_msg, iteration, session)
            
    async def _handle_timeout(self,
                        agent_state: Dict,
                        active_thread: List[str],
                        system_msg: Message,
                        iteration: int,
                        session: AsyncSession) -> Tuple[str, str]:
        """Handle the case where max iterations are reached without an answer.
        
        Returns:
            Tuple[str, str]: (timeout_message, message_id)
        """
        # Generate timeout message
        timeout_message = (
            "I've explored the document but couldn't formulate a complete answer. "
            f"Here's what I found: {self._summarize_exploration(agent_state['exploration_history'])}"
        )
        
        # Create process step for timeout
        timeout_step = AgentProcessStep(
            conversation_id=agent_state["conversation_id"],
            user_message_id=agent_state["user_message_id"],
            step_number=self._calculate_step_number(iteration + 1, "timeout"),
            step_type=AgentProcessStepType.TIMEOUT,
            content="Reached maximum exploration steps without finding a complete answer.",
            metadata={"iteration": iteration + 1}
        )
        agent_state["process_steps"].append(timeout_step)
        
        # Create and save timeout message
        parent_id = agent_state["user_message_id"] if "user_message_id" in agent_state else (
            active_thread[-1] if active_thread else system_msg.id
        )
        
        timeout_msg = Message(
            id=str(uuid.uuid4()),
            conversation_id=agent_state["conversation_id"],
            role=MessageRole.ASSISTANT,
            content=timeout_message,
            parent_id=parent_id,
            metadata={"message_type": "agent_timeout", "hidden": False}
        )
        await self.conversation_repo.add_message(timeout_msg, session)
        
        # Update the active thread if needed
        if timeout_msg.id not in active_thread:
            active_thread.append(timeout_msg.id)
        
        # Send timeout event
        if self.sse_manager:
            await self.sse_manager.send_event(
                agent_state["conversation_id"],
                "agent_timeout",
                {"message": "Agent reached the maximum number of exploration steps."}
            )
        
        return timeout_message, timeout_msg.id
    
    async def _save_process_steps(self, 
                            agent_state: Dict, 
                            assistant_message_id: str,
                            session: AsyncSession) -> None:
        """Save all process steps to the database in one batch operation."""
        if not agent_state["process_steps"]:
            logger.info("No process steps to save")
            return
            
        # Update all steps with the assistant message ID
        for step in agent_state["process_steps"]:
            step.assistant_message_id = assistant_message_id
        
        # Save in bulk
        await self.agent_process_repo.add_process_steps(agent_state["process_steps"], session)
        logger.info(f"Saved {len(agent_state['process_steps'])} process steps to database")
    
    def _calculate_step_number(self, iteration: int, step_type: str) -> int:
        """Generate a simple sequential step number based on iteration.
        
        A simpler approach - just return an integer based on the iteration.
        """
        # Each iteration can have multiple steps, so multiply by 10 to leave room
        # This gives us a simple numbering scheme: iteration 1 = 10, 11, 12...
        # iteration 2 = 20, 21, 22... etc.
        base = iteration * 10
        
        # Map step types to offsets
        step_positions = {
            "thought": 1,
            "action": 2, 
            "result": 3,
            "error": 4,
            "timeout": 5
        }
        
        offset = step_positions.get(step_type, 0)
        return base + offset
    
    def _summarize_exploration(self, exploration_history: List[Dict]) -> str:
        """Create a summary of the agent's exploration when it times out."""
        logger.info(f"Summarizing exploration after {len(exploration_history)} steps")
        
        # Focus on the most recent and relevant steps
        summary_parts = []
        
        # Get the last 5 steps or all if fewer
        recent_steps = exploration_history[-5:] if len(exploration_history) > 5 else exploration_history
        
        for step in recent_steps:
            if step["type"] == "tool_use":
                result_preview = step["result"][:100] + "..." if len(step["result"]) > 100 else step["result"]
                summary_parts.append(f"- Explored {step['action']} with input '{step['input']}' and found: {result_preview}")
        
        # Return summary or default message
        if summary_parts:
            return "\n".join(summary_parts)
        else:
            return "No significant findings to report from the exploration."